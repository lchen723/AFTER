install.packages('EnvStats')  # for data generated by GEV dis.
library(EnvStats)
library(openxlsx)


f1 <- function(x1){
  y <- 4*x1^2+x1
  return(y)
}


f2 <- function(x2){
  y <- sin(6*x2)
  return(y)
}


f3 <- function(x3){
  y <- cos(6*x3)-1
  return(y)
}


f4 <- function(x4){
  y <- 4*x4^3+x4^2
  return(y)
}


W <- function(r_star,g_x){
  # r:上次的residual ; g_x = y_hat  = fitted_value
  a <- data.frame(r_star); b <- data.frame(g_x)
  data <- cbind(a,b)
  colnames(data) <- c('Y',"X")
  w <- lm(Y~X+0,data = data)
  return(w$coefficients)
}

interval<- function(lower_bound){         #lower_bound = Y - F(k+1)(X)  upper_bound=10
  interval_size = (5-lower_bound)/5
  interval_points <- c(lower_bound)
  for(i in (1:5)){
    interval_points <- c(interval_points,lower_bound+interval_size*i)
  }
  return(interval_points)
}



distance_n_m <- c()
iterations_n_m <- c()
time_n_m<- c()
variable_catch_n_m <- list()
df_n_m <- list()

position = 0
data_n_m <-list()


distance_c_m <- c()
iterations_c_m <- c()
time_c_m<- c()
variable_catch_c_m <- list()
df_c_m <- list()
data_c_m <-list()

for(o in c(1:15)){   # 15 is the number of simulation.
  #generate Ti
  
  t<- c()
  e <- c()
  d <- c()
  covariates <- c()
  
  
  dim = 50  # dimension
  n = 500
  for (i in c(1:n)){
    p <- runif(dim,-0.5,0.5)
    # the dis of epsilon: following GEV or Normal dis.
    # error <- rgevd(1, location = 0, scale = 1, shape = 0)  
    error <- rnorm(1,0,1)
    a <- f1(p[1])+f2(p[2])+f3(p[3])+f4(p[4])+error
    t[i] <- a
    e[i] <- error
    d <- t(data.frame(p))                
    covariates <- rbind(covariates,d)
  }
  
  
  
  censoring_probability_n <- c()
  #Multinational Logistics regression
  #random to generate coefficients for x1,..x50 from -5~5
  coefficients <-matrix(runif(dim,-5,5),nrow = 1)
  for(i in c(1:dim(covariates)[1])){
    variables <- t(matrix(covariates[i,],nrow = 1))
    df4 <- coefficients%*%variables
    censoring_probability <- (exp(df4))/(1+exp(df4))
    censoring_probability_n <- c(censoring_probability_n,censoring_probability)
  }
  
  
  #generate censoring indicator by logistic regression. If value is smaller than 0.5, then makes it 0, otherwise 1.
  censoring_indicator <- (censoring_probability_n >=0.5)*1
  
  
  
  #According to censoring indicator, generate Yi. If censoring indicator equals 1, then Yi = Ti, otherwise Yi = Ti - exp(0.003)
  y <- c()
  for (i in c(1:length(censoring_indicator))){
    if (censoring_indicator[i]==1){
      y <- c(y,t[i])
    }else{
      y <- c(y,t[i]-exp(0.003))
    }
  }
  
  
  #y_with measurement, y_with_measurement = y + 1 + 1*x1 + V, where V follows N(0,1)
  df_for_y_with_measurement_error <- c()
  v <- data.frame(rnorm(length(censoring_indicator),0,0.5)) # generated eta by Normal dis.
  #v <- data.frame(rt(length(censoring_indicator),10)) # generated eta by T dis.
  constant <- data.frame(rep(1,length(censoring_indicator)))
  df_for_y_with_measurement_error <- cbind(y,constant,v,covariates[,1])
  colnames(df_for_y_with_measurement_error)[2:3] <-c('constant','v')
  y_with_measurement_error <- data.frame(apply(df_for_y_with_measurement_error,1,sum))
  
  
  
  
  #generate indicator with measurement error
  misclassification_proportion  <- matrix(c(0.9,0.1,0.1,0.9), ncol = 2) # misclassification probability
  censoring_probability_indicator_1 <- censoring_probability_n
  censoring_probability_indicator_0 <- 1 - censoring_probability_n
  df5 <- cbind(censoring_probability_indicator_1,censoring_probability_indicator_0)
  censoring_indicator_with_measurement_error <- NULL
  
  
  #if Probability of censoring indicator star >= 0.5, then censoring indicator star = 1, otherwise = 0
  for (i in c(1:length(censoring_indicator))){
    df6 <- misclassification_proportion %*%df5[i,]
    if (df6[1,]>=0.5){
      censoring_indicator_with_measurement_error <- c(censoring_indicator_with_measurement_error,1)
    }else{
      censoring_indicator_with_measurement_error <- c(censoring_indicator_with_measurement_error,0)
    }
  }
  

  estimated_w <- 1+ 1*mean(covariates[,1])+mean(v[,1])
  correction_last_part <- covariates[,1]-mean(covariates[,1])
  y_hat <- data.frame(y_with_measurement_error - estimated_w-correction_last_part)
  colnames(y_hat) <- c("y_hat")
  
  # correction for misclassification, misclassification probability = 0.1
  indicator_hat_probability <- (censoring_indicator_with_measurement_error-0.1)/(1-0.1-0.1)  
  indicator_hat <- NULL
  for (i in c(1:length(indicator_hat_probability))){
    if (indicator_hat_probability[i]<0){
      indicator_hat[i] <- 0
    }else{
      indicator_hat[i] <- 1
    }
  }
  indicator_hat
  

  
  #boosting for naive data
  #naive data
  naive_data <- cbind(y_with_measurement_error,censoring_indicator_with_measurement_error,e,covariates)
  colnames(naive_data)[1:2] <- c('Y','censoring_indicator')
  
  
  
  # number of sample
  n = dim(covariates)[1]
  # dimension
  p = dim(covariates)[2]
  
  
  
  censoring_indicator <- naive_data$censoring_indicator
  variable_catch <- c()
  #sum_riemann_for_every_m <- c()
  y <- naive_data$Y
  #w_weight <- c()
  
  #step 0.
  t1 <- proc.time()
  sum_of_every_fitted_value <- rep(0,times=n)   #F(K)(X)
  y_star <- naive_data$Y
  r <- y - sum_of_every_fitted_value
  r_star <- y_star - sum_of_every_fitted_value
  df3 <- data.frame(naive_data$censoring_indicator,r_star,r)
  colnames(df3)[1] <- "censoring_indicator"
  survival_probability <- c()
  
  for (i in c(1:dim(df3)[1])){
    yy <- df3[df3$r<=df3$r[i],]
    u <- c(yy$r)
    data_producted <- 1
    for (j in c(1:length(u))){
      #分母
      total_sum_of_denominator <- sum((df3$r>=u[j])*1)
      #分子
      censoring_indicator_1<- df3[df3$censoring_indicator==1,]
      total_sum_of_numerator <- sum((censoring_indicator_1$r==u[j])*1)
      data_producted = data_producted * (1-total_sum_of_numerator/total_sum_of_denominator)
    }
    survival_probability[i] <- data_producted
  }
  
  
  
  survival_probability[which(survival_probability==0)] <- 0.000001
  
  
  sum_riemann_for_every_n <- c()
  for (i in c(1:length(df3$r))){
    point <- interval(df3$r[i])
    riemann_x <- c()
    data_producted <- 1
    for (j in c(1:length(point))){
      xx <- df3[df3$r<=point[j],]       
      u <- c(xx$r)
      for (k in c(1:length(u))){
        total_sum_of_denominator <- sum((df3$r>=u[k])*1)
        censoring_indicator_1<- df3[df3$censoring_indicator==1,]
        total_sum_of_numerator <- sum((censoring_indicator_1$r==u[k])*1)
        data_producted = data_producted *  (1-total_sum_of_numerator/total_sum_of_denominator)
      }
      riemann_x[j]<- data_producted
    }
    
    riemann_minus <- c()
    for (l in c(1:length(riemann_x)-1)){
      riemann_minus[l] <- riemann_x[l+1]-riemann_x[l]
    }
    
    
    sum_integrate <-c(0)
    for (m in c(1:length(riemann_minus))){
      sum_integrate <- sum_integrate + point[m+1] * riemann_minus[m]
    }
    sum_riemann_for_every_n[i] <- sum_integrate
  }
  
  
  y_star_update <- c()
  for (i in c(1:length(y))){
    y_star_update[i] <- censoring_indicator[i] * y[i]+
      (1-censoring_indicator[i])*(sum_of_every_fitted_value[i] - sum_riemann_for_every_n[i]/survival_probability[i])
  }
  
  
  y_star <- y_star_update
  
  
  add_g_every_time <- data.frame()
  df <- as.data.frame(matrix(numeric(0),ncol = p, nrow = n))
  df[is.na(df)] <- 0 
  for (i in c(1:p)){
    colnames(df)[i] <- i
  }
  
  
  iterations = 0
  stop_times = 50
  
  
  while (TRUE) {
    
    if (iterations == stop_times){
      break
    }
    r_star <- y_star - sum_of_every_fitted_value
    residual<- c(0)
    add_f <- c()
    times <- c(0)
    variable <- c()
    
    
    for (i in c(1:p)){  # p is the number of variable which can be selected in the iteration.
      times = times + 1
      f_variables <- smooth.spline(x=naive_data[,i+3],y=r_star,cv=FALSE,all.knots=c(0,0.2,0.4,0.6,0.8,1))
      if (residual==0){
        add_f <- f_variables
        residual <- f_variables$pen.crit
        variable <- times
      } else if(f_variables$pen.crit < residual){
        add_f <- f_variables
        variable <- times
        residual <- f_variables$pen.crit
      }
    }
    
    
    variable_catch <- c(variable_catch,variable)
    fit = fitted(add_f)
    fit[which(is.na(fit))]=0
    
    w <- W(r_star,fit)
    
    add_g <- as.data.frame(w * fit, ncol = 1)

    
    stop_value <- 1e-2
    number_of_added_value <- sum((add_g < stop_value)*1)
    
    
    
    
    if (number_of_added_value != n){
      df[as.character(variable)] <- df[,variable] + add_g
      
  
      sum_of_every_fitted_value <- sum_of_every_fitted_value + w * fit
      r_star = y_star - sum_of_every_fitted_value
      r <- y - sum_of_every_fitted_value
      df1 <- data.frame(naive_data$censoring_indicator,r_star,r)
      colnames(df1)[1] <- "censoring_indicator"
      survival_probability <- c()
      
      for (i in c(1:dim(df1)[1])){
        yy <- df1[df1$r<=df1$r[i],]
        u <- c(yy$r)
        data_producted <- 1
        for (j in c(1:length(u))){
          total_sum_of_denominator <- sum((df1$r>=u[j])*1)
          censoring_indicator_1<- df1[df1$censoring_indicator==1,]
          total_sum_of_numerator <- sum((censoring_indicator_1$r==u[j])*1)
          data_producted = data_producted * (1-total_sum_of_numerator/total_sum_of_denominator)
        }
        survival_probability[i] <- data_producted
      }
      
      survival_probability[which(survival_probability==0)] <- 0.000001
      
      sum_riemann_for_every_n <- c()
      
      for (i in c(1:length(df1$r))){
        point <- interval(df1$r[i])
        riemann_x <- c()
        data_producted <- 1
        for (j in c(1:length(point))){
          xx <- df1[df1$r<=point[j],]       
          u <- c(xx$r)
          for (k in c(1:length(u))){
            total_sum_of_denominator <- sum((df1$r>=u[k])*1)
            total_sum_of_denominator
            censoring_indicator_1<- df1[df1$censoring_indicator==1,]
            total_sum_of_numerator <- sum((censoring_indicator_1$r==u[k])*1)
            data_producted = data_producted *  (1-total_sum_of_numerator/total_sum_of_denominator)
          }
          riemann_x[j]<- data_producted
        }
        
        riemann_minus <- c()
        for (l in c(1:length(riemann_x)-1)){
          riemann_minus[l] <- riemann_x[l+1]-riemann_x[l]
        }
        
        
        sum_integrate <-c(0)
        for (m in c(1:length(riemann_minus))){
          sum_integrate <- sum_integrate + point[m+1] * riemann_minus[m]
        }
        sum_riemann_for_every_n[i] <- sum_integrate
      }
      
      
      y_star_update <- c()
      
      for (i in c(1:length(y))){
        y_star_update[i] <- censoring_indicator[i] * y[i]+
          (1-censoring_indicator[i])*(sum_of_every_fitted_value[i] - sum_riemann_for_every_n[i]/survival_probability[i])
      }
      
      y_star <- y_star_update
      
      iterations = iterations + 1
      
    }else{
      break
    }
  }
  
  t2 <- proc.time()
  a <- abs(max(f1(naive_data[,4])-df[,1]))
  b <- abs(max(f2(naive_data[,5])-df[,2]))
  c <- abs(max(f3(naive_data[,6])-df[,3]))
  d <- abs(max(f4(naive_data[,7])-df[,4]))
  distance <- sum(a+b+c+d)
  position <- position + 1
  t <- t2-t1
  distance_n_m <- c(distance_n_m,distance)
  variable_catch_n_m[[position]] <- variable_catch
  iterations_n_m <- c(iterations_n_m, iterations)
  time_n_m<- c(time_n_m,t[3][[1]])
  df_n_m[[position]] <- df[,1:4]
  data_n_m[[position]] <- naive_data[,4:7]
  
  
  #boosting for corrected data
  #corrected data
  corrected_data<- cbind(y_hat,indicator_hat,e,covariates)
  colnames(corrected_data)[1:2] <- c('Y','censoring_indicator')
  
  # number of data
  n = dim(covariates)[1]
  # dimension
  p = dim(covariates)[2]
  
  censoring_indicator <- corrected_data$censoring_indicator
  variable_catch <- c()
  sum_riemann_for_every_m <- c()
  y <- corrected_data$Y
  w_weight <- c()
  
  
  #step 0.
  t1 <- proc.time()
  sum_of_every_fitted_value <- rep(0,times=n)   
  y_star <- corrected_data$Y
  r <- y - sum_of_every_fitted_value
  r_star <- y_star - sum_of_every_fitted_value
  df3 <- data.frame(corrected_data$censoring_indicator,r_star,r)
  colnames(df3)[1] <- "censoring_indicator"
  survival_probability <- c()
  
  for (i in c(1:dim(df3)[1])){
    yy <- df3[df3$r<=df3$r[i],]
    u <- c(yy$r)
    data_producted <- 1
    for (j in c(1:length(u))){
      total_sum_of_denominator <- sum((df3$r>=u[j])*1)
      censoring_indicator_1<- df3[df3$censoring_indicator==1,]
      total_sum_of_numerator <- sum((censoring_indicator_1$r==u[j])*1)
      data_producted = data_producted * (1-total_sum_of_numerator/total_sum_of_denominator)
    }
    survival_probability[i] <- data_producted
  }
  
  
  
  survival_probability[which(survival_probability==0)] <- 0.000001
  
  
  
  
  sum_riemann_for_every_n <- c()
  for (i in c(1:length(df3$r))){
    point <- interval(df3$r[i])
    riemann_x <- c()
    data_producted <- 1
    for (j in c(1:length(point))){
      xx <- df3[df3$r<=point[j],]     
      u <- c(xx$r)
      for (k in c(1:length(u))){
        total_sum_of_denominator <- sum((df3$r>=u[k])*1)
        censoring_indicator_1<- df3[df3$censoring_indicator==1,]
        total_sum_of_numerator <- sum((censoring_indicator_1$r==u[k])*1)
        data_producted = data_producted *  (1-total_sum_of_numerator/total_sum_of_denominator)
      }
      riemann_x[j]<- data_producted
    }
    
    riemann_minus <- c()
    for (l in c(1:length(riemann_x)-1)){
      riemann_minus[l] <- riemann_x[l+1]-riemann_x[l]
    }
    
    
    sum_integrate <-c(0)
    for (m in c(1:length(riemann_minus))){
      sum_integrate <- sum_integrate + point[m+1] * riemann_minus[m]
    }
    sum_riemann_for_every_n[i] <- sum_integrate
  }
  
  
  y_star_update <- c()
  for (i in c(1:length(y))){
    y_star_update[i] <- censoring_indicator[i] * y[i]+
      (1-censoring_indicator[i])*(sum_of_every_fitted_value[i] - sum_riemann_for_every_n[i]/survival_probability[i])
  }
  
  
  y_star <- y_star_update
  add_g_every_time <- data.frame()
  df <- as.data.frame(matrix(numeric(0),ncol = p, nrow = n))
  df[is.na(df)] <- 0 
  for (i in c(1:p)){
    colnames(df)[i] <- i
  }
  
  
  
  iterations = 1
  stop_times = 50
  
  while (TRUE) {
    if (iterations == stop_times){
      break
    }
    r_star <- y_star - sum_of_every_fitted_value
    residual<- c(0)
    sum_of_every_fitted_value
    add_f <- c()
    times <- c(0)
    variable <- c()
    
    
    for (i in c(1:p)){   # p is the number of variable which can be selected in the iteration.
      times = times + 1
      f_variables <- smooth.spline(x=corrected_data[,i+3],y=r_star,cv=TRUE,all.knots=c(0,0.2,0.4,0.6,0.8,1)) 
      if (residual==0){
        add_f <- f_variables
        residual <- f_variables$pen.crit
        variable <- times
      } else if(f_variables$pen.crit < residual){
        add_f <- f_variables
        variable <- times
        residual <- f_variables$pen.crit
      }
    }
    
    
    variable_catch <- c(variable_catch,variable)
    fit = fitted(add_f)
    fit[which(is.na(fit))]=0
    
    w <- W(r_star,fit)
    w_weight <- c(w_weight,w)
    
    add_g <- as.data.frame(w * fit, ncol = 1)
    
    stop_value <- 1e-2
    number_of_added_value <- sum((add_g < stop_value)*1)
    
    
    if (number_of_added_value != n){
      df[as.character(variable)] <- df[,variable] + add_g
      
      sum_of_every_fitted_value <- sum_of_every_fitted_value + w * fit
      r_star = y_star - sum_of_every_fitted_value
      r <- y - sum_of_every_fitted_value
      df1 <- data.frame(corrected_data$censoring_indicator,r_star,r)
      colnames(df1)[1] <- "censoring_indicator"
      survival_probability <- c()
      
      for (i in c(1:dim(df1)[1])){
        yy <- df1[df1$r<=df1$r[i],]
        u <- c(yy$r)
        data_producted <- 1
        for (j in c(1:length(u))){
          total_sum_of_denominator <- sum((df1$r>=u[j])*1)
          censoring_indicator_1<- df1[df1$censoring_indicator==1,]
          total_sum_of_numerator <- sum((censoring_indicator_1$r==u[j])*1)
          data_producted = data_producted * (1-total_sum_of_numerator/total_sum_of_denominator)
        }
        survival_probability[i] <- data_producted
      }
      
      survival_probability[which(survival_probability==0)] <- 0.000001
      
      sum_riemann_for_every_n <- c()
      
      for (i in c(1:length(df1$r))){
        point <- interval(df1$r[i])
        riemann_x <- c()
        data_producted <- 1
        for (j in c(1:length(point))){
          xx <- df1[df1$r<=point[j],]       
          u <- c(xx$r)
          for (k in c(1:length(u))){
            total_sum_of_denominator <- sum((df1$r>=u[k])*1)
            total_sum_of_denominator
            censoring_indicator_1<- df1[df1$censoring_indicator==1,]
            total_sum_of_numerator <- sum((censoring_indicator_1$r==u[k])*1)
            data_producted = data_producted *  (1-total_sum_of_numerator/total_sum_of_denominator)
          }
          riemann_x[j]<- data_producted
        }
        
        riemann_minus <- c()
        for (l in c(1:length(riemann_x)-1)){
          riemann_minus[l] <- riemann_x[l+1]-riemann_x[l]
        }
        
        
        sum_integrate <-c(0)
        for (m in c(1:length(riemann_minus))){
          sum_integrate <- sum_integrate + point[m+1] * riemann_minus[m]
        }
        sum_riemann_for_every_n[i] <- sum_integrate
      }
      
      y_star_update <- c()
      
      for (i in c(1:length(y))){
        y_star_update[i] <- censoring_indicator[i] * y[i]+
          (1-censoring_indicator[i])*(sum_of_every_fitted_value[i] - sum_riemann_for_every_n[i]/survival_probability[i])
      }
      
      y_star <- y_star_update
      iterations = iterations + 1
      
    }else{
      break
    }
  }
  
  
  t2 <- proc.time()
  a <- abs(max(f1(corrected_data[,4])-df[,1]))
  b <- abs(max(f2(corrected_data[,5])-df[,2]))
  c <- abs(max(f3(corrected_data[,6])-df[,3]))
  d <- abs(max(f4(corrected_data[,7])-df[,4]))
  distance <- sum(a+b+c+d)
  t <- t2-t1
  distance_c_m <- c(distance_c_m,distance)
  variable_catch_c_m[[position]] <- variable_catch
  iterations_c_m <- c(iterations_c_m, iterations)
  time_c_m<- c(time_c_m,t[3][[1]])
  df_c_m[[position]] <- df[,1:4]
  data_c_m[[position]] <- corrected_data[,4:7]
  
  
}

count <- function(variable_catch){
  one <- 0
  two <- 0
  three <- 0
  four <- 0
  all <- 0
  number = length(variable_catch)
  for (i in c(1:length(variable_catch))){
    if (1 %in% variable_catch[[i]]){
      one = one + 1
    }
    if (2 %in% variable_catch[[i]]){
      two = two + 1
    }
    if (3 %in% variable_catch[[i]]){
      three = three + 1
    }
    if (4 %in% variable_catch[[i]]){
      four = four + 1
    }
    if (mean((c(1,2,3,4) %in% variable_catch[[i]])*1)==1){
      all = all + 1
    }
  }
  data = list(one / number,two / number,three / number,four / number,all / number)
  return(data)
}


data1234 <- count(variable_catch_n_m)
data1234 # The percentage of variable that are selected in the iteration for naive data
mean(distance_n_m) # Average bias for naive data
mean(time_n_m) # Average time of 15 iterations for naive data
mean(iterations_n_m) # Average times of in iteration
list1 <- c(data1234,mean(distance_n_m),mean(time_n_m),mean(iterations_n_m))


jpeg("nn505011.jpeg",width = 450, height = 511) # change the name of variable
#1
plot(c(-0.5,0.5),c(-1,3), xlab="x",ylab='f', main= 'X1')
curve( 4*x^2+x,-1,1, col='black',add = TRUE,lwd=2)

for (i in c(1:15)){
  x_1 <- as.data.frame(cbind(data_n_m[[i]][,1],df_n_m[[i]][,1]))
  colnames(x_1) <- c('x','y')
  x_1 <- x_1[order(x_1$x),]
  lines(x_1$x,x_1$y,col='dark gray', lwd=2,lty=2)
}
dev.off()


jpeg("nn505012.jpeg",width = 450, height = 511)  # change the name of variable
#2
plot(c(-0.5,0.5),c(-1.5,3), xlab="x",ylab='f', main= 'X2')
curve(sin(6*x),-1,1, col='black',add = TRUE,lwd=2)
for (i in c(1:15)){
  x_2 <- as.data.frame(cbind(data_n_m[[i]][,2],df_n_m[[i]][,2]))
  colnames(x_2) <- c('x','y')
  x_2 <- x_2[order(x_2$x),]
  lines(x_2$x,x_2$y,col='dark gray', lwd=2,lty=2)
}
dev.off()

jpeg("nn505013.jpeg",width = 450, height = 511) # change the name of variable
#3
plot(c(-0.5,0.5),c(-2,2.5), xlab="x",ylab='f', main= 'X3')
curve(cos(6*x)-1,-1,1, col='black',add = TRUE,lwd=2)
for (i in c(1:15)){
  x_3 <- as.data.frame(cbind(data_n_m[[i]][,3],df_n_m[[i]][,3]))
  colnames(x_3) <- c('x','y')
  x_3 <- x_3[order(x_3$x),]
  lines(x_3$x,x_3$y,col='dark gray', lwd=2,lty=2)
}
dev.off()


jpeg("nn505014.jpeg",width = 450, height = 511) # change the name of variable
#4
plot(c(-0.5,0.5),c(-1,3), xlab="x",ylab='f', main= 'X4')
curve(4*x^3+x^2,-1,1, col='black',add = TRUE,lwd=2)
for (i in c(1:15)){
  x_4 <- as.data.frame(cbind(data_n_m[[i]][,4],df_n_m[[i]][,4]))
  colnames(x_4) <- c('x','y')
  x_4 <- x_4[order(x_4$x),]
  lines(x_4$x,x_4$y,col='dark gray', lwd=2,lty=2)
}
dev.off()


data1234 <- count(variable_catch_c_m)
data1234 # The percentage of variable that are selected in the iteration for corrected data
mean(distance_c_m) # Average bias for corrected data
mean(time_c_m)  # Average time of 15 iterations for corrected data 
mean(iterations_c_m) # Average times of in iteration
list2 <- c(data1234,mean(distance_c_m),mean(time_c_m),mean(iterations_c_m))
list <- list(list1,list2)
write.xlsx(file = "nn50501.xlsx", list, sheetName=c('n','c')) # output data to csv.file


jpeg("nn505015.jpeg",width = 450, height = 511) # change the name of variable
#5
plot(c(-0.5,0.5),c(-1,3), xlab="x",ylab='f', main= 'X1')
curve( 4*x^2+x,-1,1, col='black',add = TRUE,lwd=2)
for (i in c(1:15)){
  x_1 <- as.data.frame(cbind(data_c_m[[i]][,1],df_c_m[[i]][,1]))
  colnames(x_1) <- c('x','y')
  x_1 <- x_1[order(x_1$x),]
  lines(x_1$x,x_1$y,col='dark gray', lwd=2,lty=2)
}
dev.off()

jpeg("nn505016.jpeg",width = 450, height = 511) # change the name of variable
#6
plot(c(-0.5,0.5),c(-1.5,3), xlab="x",ylab='f', main= 'X2')
curve(sin(6*x),-1,1, col='black',add = TRUE,lwd=2)
for (i in c(1:15)){
  x_2 <- as.data.frame(cbind(data_c_m[[i]][,2],df_c_m[[i]][,2]))
  colnames(x_2) <- c('x','y')
  x_2 <- x_2[order(x_2$x),]
  lines(x_2$x,x_2$y,col='dark gray', lwd=2,lty=2)
}
dev.off()

jpeg("nn505017.jpeg",width = 450, height = 511) # change the name of variable
#7
plot(c(-0.5,0.5),c(-2,2), xlab="x",ylab='f', main= 'X3')
curve(cos(6*x)-1,-1,1, col='black',add = TRUE,lwd=2)
#curve(cos(6*x),-1,1, col='black',add = TRUE,lwd=2)
for (i in c(1:15)){
  x_3 <- as.data.frame(cbind(data_c_m[[i]][,3],df_c_m[[i]][,3]))
  colnames(x_3) <- c('x','y')
  x_3 <- x_3[order(x_3$x),]
  lines(x_3$x,x_3$y,col='dark gray', lwd=2,lty=2)
}
dev.off()


jpeg("nn505018.jpeg",width = 450, height = 511) # change the name of variable
#8
plot(c(-0.5,0.5),c(-1,3), xlab="x",ylab='f', main= 'X4')
curve(4*x^3+x^2,-1,1, col='black',add = TRUE,lwd=2)
for (i in c(1:15)){
  x_4 <- as.data.frame(cbind(data_c_m[[i]][,4],df_c_m[[i]][,4]))
  colnames(x_4) <- c('x','y')
  x_4 <- x_4[order(x_4$x),]
  lines(x_4$x,x_4$y,col='dark gray', lwd=2,lty=2)
}
dev.off()

save.image(file="nn50501.RData") # output environment variable to R.data

